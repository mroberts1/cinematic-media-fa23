---
title: ''
format: html
echo: false
observable: 'https://observablehq.com/@harrystevens/vanilla-boids'
---

```{ojs}
{
  let startTime = (new Date()).getTime(), seconds = 0, secondsRounded = 0, ticks = 0, speeds = [];

  const ctx = DOM.context2d(myBoids.width(), myBoids.height());

  let holding = false;
  ctx.canvas.addEventListener("mousedown", e => { holding = true; addBoidOnEvent(e); });
  ctx.canvas.addEventListener("mouseup", e => { holding = false });
  ctx.canvas.addEventListener("mousemove", e => { if (holding) addBoidOnEvent(e); });

  while (true && myBoids.flock.length){
    myBoids.tick();
    ctx.clearRect(0, 0, myBoids.width(), myBoids.height());

    myBoids.each(boid => {
      const a = vecmath.trans(boid.pos, boid.ang - Math.PI * .5, 3),
            b = vecmath.trans(boid.pos, boid.ang, 9),
            c = vecmath.trans(boid.pos, boid.ang + Math.PI * .5, 3);

      ctx.beginPath();

      ctx.moveTo(...a);
      ctx.lineTo(...b);
      ctx.lineTo(...c);
      ctx.lineTo(...a);

      const color = d3.interpolateRdPu(.6 * myBoids.maxSpeed() / boid.speed);
      ctx.strokeStyle = color;
      ctx.fillStyle = d3.color(color).brighter(2);

      ctx.fill();
      ctx.stroke();
    });

    seconds = ((new Date()).getTime() - startTime) / 1e3;
    ticks++;
    document.querySelector(".ticker").innerHTML = `${myBoids.flock.length} boids at ${d3.mean(speeds)} frames per second`;

    if (Math.round(seconds) !== secondsRounded){
      speeds.push(ticks);
      if (speeds.length > 2) speeds.shift();
      secondsRounded = Math.round(seconds);
      ticks = 0;
    }

    yield ctx.canvas;
  }
}
```

```{ojs}
{
  const el = DOM.element("div");
  el.classList.add("ticker");
  return el;
}
```

```{ojs}
viewof useTree = checkbox({
  options: [{ value: "true", label: "Use RBush" }],
  value: "true",
  description: "Use a quadtree to improve performance"
})
```

```{ojs}
viewof alignment = slider({
  title: "Alignment",
  value: 1,
  min: 0,
  max: 1,
  step: .1,
  description: "Steer towards the average heading of local flockmates"
});
```

```{ojs}
viewof cohesion = slider({
  title: "Cohesion",
  value: 1,
  min: 0,
  max: 1,
  step: .1,
  description: "Steer towards the average position of local flockmates"
});
```

```{ojs}
viewof separation = slider({
  title: "Separation",
  value: 1,
  min: 0,
  max: 1,
  step: .1,
  description: "Steer to avoid crowding local flockmates"
});
```

```{ojs}
viewof perception = slider({
  title: "Perception",
  value: 20,
  min: 1,
  max: 60,
  step: 1,
  description: "Maximum distance of other boids to consider"
});
```

```{ojs}
toc({selector: "h2"})
```

```{ojs}
md`## API Reference

To use the Boids class in your own notebook ([example](https://observablehq.com/@harrystevens/minimalist-boids?collection=@harrystevens/boids)):

~~~js
import { Boids } from "@harrystevens/vanilla-boids"
~~~

<b>Boids</b>

Creates a new simulation, setting <i>alignment</i>, <i>cohesion</i>, and <i>separation</i> to 1, <i>perception</i> to 20, <i>width</i> to the notebook’s width, and <i>height</i> to 500.

~~~js
const myBoids = new Boids();
~~~

boids.<b>add</b>([<i>options</i>])

Adds a boid to the simulation with a random position and angle, and with a speed of 1, and returns the simulation. You can pass an <i>options</i> object with the following properties:

| property | type   | description                                                                                                                                                 |
|----------|--------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|
| pos      | Array  | Starting position for the boid, specified as an array of two numbers, where the first number is the x-coordinate and the second number is the y-coordinate. |
| ang      | Number | Starting angle for the boid, specified as a number in radians.                                                                                                |
| speed    | Number | Starting speed for the boid, specified as a number.                                                                                                         |
<br />

boids.<b>each</b>(<i>accessor</i>)

Loops through the flock of boids, invoking an <i>accessor</i> function on each boid one at a time. The accessor is passed three arguments: the current boid, the current index, and the entire flock.

boids.<b>tick</b>()

Advances the simulation one tick and returns the simulation.

boids.<b>alignment</b>([<i>alignment</i>])

If <i>alignment</i> is specified, sets the alignment force to a number and returns the simulation. Alignment forces the boids to steer towards the average heading of local flockmates. If <i>alignment</i> is not specified, returns the current alignment force, which defaults to 1.

boids.<b>cohesion</b>([<i>cohesion</i>])

If <i>cohesion</i> is specified, sets the cohesion force to a number and returns the simulation. Cohesion forces the boids to steer towards the average position of local flockmates. If <i>cohesion</i> is not specified, returns the current cohesion force, which defaults to 1.

boids.<b>separation</b>([<i>separation</i>])

If <i>separation</i> is specified, sets the separation force to a number and returns the simulation. Separation forces the boids to steer to avoid crowding local flockmates. If <i>separation</i> is not specified, returns the current separation force, which defaults to 1.

boids.<b>perception</b>([<i>perception</i>])

If <i>perception</i> is specified, sets the perception radius of the boids to a number of pixels and returns the simulation. The boids’ movement will be affected only by those other boids whose positions fall within the perception radius. If <i>perception</i> is not specified, returns the current perception radius, which defaults to 20.

boids.<b>width</b>([<i>width</i>])

If <i>width</i> is specified, sets the width of the simulation to a number of pixels and returns the simulation. If <i>width</i> is not specified, returns the current width, which defaults to the notebook’s width.

boids.<b>height</b>([<i>height</i>])

If <i>height</i> is specified, sets the height of the simulation to a number of pixels and returns the simulation. If <i>height</i> is not specified, returns the current height, which defaults to 500.

boids.<b>maxSpeed</b>([<i>speed</i>])

If <i>speed</i> is specified, sets the maximum speed of the boids to a number of pixels per tick and returns the simulation. If <i>speed</i> is not specified, returns the current maximum speed, which defaults to 4.
`
```

```{ojs}
md`## Code`
```

```{ojs}
myBoids = {
  const sim = new Boids();

  // Add 500 boids
  for (let i = 0; i < 500; i++) {
    sim.add();
  }

  return sim;
}
```

```{ojs}
myBoids
  .alignment(alignment)
  .cohesion(cohesion)
  .separation(separation)
  .perception(perception)
  .quadtree(!!useTree);
```

```{ojs}
function addBoidOnEvent(e){
  myBoids.add({
    pos: [e.offsetX, e.offsetY]
  });
}
```

```{ojs}
class Boids {
  constructor(){
    this._width = width;
    this._height = height;
    this._perception = 20;
    this._alignment = 1;
    this._cohesion = 1;
    this._separation = 1;
    this._maxSpeed = 4;
    this._quadtree = true;
    this.maxForce = 0.2;
    this.flock = [];
    this.tree = new BoidBush();
  }

  alignment(n){
    if (isFinite(n)){
      this._alignment = n;
      for (let i = 0, l = this.flock.length; i < l; i++){
        this.flock[i]._alignment = n;
      }
      return this;
    }
    else {
      return this._alignment;
    }
  }

  cohesion(n){
    if (isFinite(n)){
      this._cohesion = n;
      for (let i = 0, l = this.flock.length; i < l; i++){
        this.flock[i]._cohesion = n;
      }
      return this;
    }
    else {
      return this._cohesion;
    }
  }

  perception(n){
    if (isFinite(n)){
      this._perception = n;
      for (let i = 0, l = this.flock.length; i < l; i++){
        this.flock[i]._perception = n;
      }
      return this;
    }
    else {
      return this._perception;
    }
  }

  separation(n){
    if (isFinite(n)){
      this._separation = n;
      for (let i = 0, l = this.flock.length; i < l; i++){
        this.flock[i]._separation = n;
      }
      return this;
    }
    else {
      return this._separation;
    }
  }

  width(n){
    if (isFinite(n)){
      this._width = n;
      for (let i = 0, l = this.flock.length; i < l; i++){
        this.flock[i]._width = n;
      }
      return this;
    }
    else {
      return this._width;
    }
  }

  height(n){
    if (isFinite(n)){
      this._height = n;
      for (let i = 0, l = this.flock.length; i < l; i++){
        this.flock[i]._height = n;
      }
      return this;
    }
    else {
      return this._height;
    }
  }

  quadtree(bool){
    if (arguments.length) {
      this._quadtree = bool;
      if (this._quadtree && !this.tree) this.tree = new BoidBush();
      for (let i = 0, l = this.flock.length; i < l; i++){
        this.flock[i]._quadtree = bool;
        this.flock[i].tree = this.tree;
      }
      return this;
    }
    else {
      return this._quadtree;
    }
  }

  maxSpeed(n){
    if (isFinite(n)){
      this._maxSpeed = n;
      for (let i = 0, l = this.flock.length; i < l; i++){
        this.flock[i]._maxSpeed = n;
      }
      return this;
    }
    else {
      return this._maxSpeed;
    }
  }

  add(opts){
    this.flock.push(new Boid(this, opts));
    return this;
  }

  each(fn){
    for (let i = 0, l = this.flock.length; i < l; i++){
      fn(this.flock[i], i, this.flock);
    }
    return this;
  }

  tick(){
    if (this._quadtree) {
      this.tree.clear();
      this.tree.load(this.flock);
    }

    this.each(boid => boid.update());

    return this;
  }
}
```

```{ojs}
class Boid {
  constructor(Boids, opts){
    Object.assign(this, Boids);
    Object.assign(this, opts);

    // Angle, position, and speed can be assigned by the user.
    this.ang = this.ang || 2 * Math.random() * Math.PI;
    this.pos = this.pos || [
      Math.random() * this._width,
      Math.random() * this._height
    ];
    this.speed = this.speed || 1;

    const obj = {
      pos: this.pos,
      ang: this.ang,
      speed: this.speed,
      vel: vecmath.sub(
        vecmath.trans(this.pos, this.ang, this.speed),
        this.pos
      ),
      acc: [0, 0],
      id: this.flock.length
    };

    Object.assign(this, obj);
  }

  update(){
    const prev = { ...this };

    let alignment = [0, 0],
        cohesion = [0, 0],
        separation = [0, 0],
        n = 0,
        candidates = this.flock;

    if (this._quadtree){
      candidates = this.tree.search({
        minX: this.pos[0] - this._perception,
        minY: this.pos[1] - this._perception,
        maxX: this.pos[0] + this._perception,
        maxY: this.pos[1] + this._perception,
      });
    }

    for (let i = 0, l = candidates.length; i < l; i ++){
      const that = candidates[i],
            dist = vecmath.dist(this.pos, that.pos);

      if (this.id !== that.id && dist < this._perception){
        alignment = vecmath.add(alignment, that.vel);
        cohesion = vecmath.add(cohesion, that.pos);
        const diff = vecmath.div(
          vecmath.sub(this.pos, that.pos),
          Math.max(dist, epsilon)
        );
        separation = vecmath.add(separation, diff);
        n++;
      }
    }

    if (n > 0){
      alignment = vecmath.div(alignment, n);
      alignment = vecmath.setMag(alignment, this._maxSpeed);
      alignment = vecmath.sub(alignment, this.vel);
      alignment = vecmath.limit(alignment, this.maxForce);

      cohesion = vecmath.div(cohesion, n);
      cohesion = vecmath.sub(cohesion, this.pos);
      cohesion = vecmath.setMag(cohesion, this._maxSpeed);
      cohesion = vecmath.sub(cohesion, this.vel);
      cohesion = vecmath.limit(cohesion, this.maxForce);

      separation = vecmath.div(separation, n);
      separation = vecmath.setMag(separation, this._maxSpeed);
      separation = vecmath.sub(separation, this.vel);
      separation = vecmath.limit(separation, this.maxForce);
    }

    alignment = vecmath.mult(alignment, this._alignment);
    cohesion = vecmath.mult(cohesion, this._cohesion);
    separation = vecmath.mult(separation, this._separation);

    this.acc = vecmath.add(this.acc, alignment);
    this.acc = vecmath.add(this.acc, cohesion);
    this.acc = vecmath.add(this.acc, separation);

    this.pos = vecmath.add(this.pos, this.vel);
    this.vel = vecmath.add(this.vel, this.acc);
    this.vel = vecmath.limit(this.vel, this._maxSpeed);

    if (this.pos[0] > this._width) this.pos[0] = 0;
    if (this.pos[0] < 0) this.pos[0] = this._width;
    if (this.pos[1] > this._height) this.pos[1] = 0;
    if (this.pos[1] < 0) this.pos[1] = this._height;

    this.ang = vecmath.ang(prev.pos, this.pos);
    this.speed = vecmath.dist(prev.pos, this.pos);

    this.acc = vecmath.mult(this.acc, 0);
  }
}
```

```{ojs}
class BoidBush extends RBush {
  toBBox(boid) { return {minX: boid.pos[0], minY: boid.pos[1], maxX: boid.pos[0], maxY: boid.pos[1]}; }
  compareMinX(a, b) { return a.pos[0] - b.pos[0]; }
  compareMinY(a, b) { return a.pos[1] - b.pos[1]; }
}
```

```{ojs}
height = 500;
```

```{ojs}
epsilon = 1e-6;
```

```{ojs}
html`<style>
table td, table th {
  padding: 4px;
}
.ticker {
  color: #555;
  font-size: 14px;
  margin-top: -10px;
  text-align: right;
}
</style>`
```

```{ojs}
import { checkbox, slider } from "@jashkenas/inputs";
```

```{ojs}
import { toc } from "@harrystevens/toc";
```

```{ojs}
import { vecmath } from "@harrystevens/vector-math";
```

```{ojs}
d3 = require("d3-array@1", "d3-color@1", "d3-scale-chromatic@1");
```

```{ojs}
RBush = require("rbush@3");
```



